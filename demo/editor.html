<meta charset="UTF-8" />
<html>
    <head>
        <link rel="stylesheet" href="../public/plugins/prism/prism.css">
        <link rel="stylesheet" href="../public/css/OntologyEditor.css">
        <script type="text/javascript" src="../public/plugins/prism/prism.js"></script>
        <style>
            body {
                padding: 15px;
                font-family: Helvetica;
            }
        </style>
    </head>
    <body>
        Show HN: Symatem meets WebAssembly - an online ontology engine, visualizer and editor<br />
        <br />
        <a class="github-button" href="https://github.com/Symatem/Symatem" data-icon="octicon-star" data-style="mega" data-count-href="/Symatem/Symatem/stargazers" data-count-api="/repos/Symatem/Symatem#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star Symatem/Symatem on GitHub">Star</a>
        <h1>Symatem Ontology Editor</h1>
        <p>
            What you can see below is an <a href="https://en.wikipedia.org/wiki/Ontology_(information_science)">ontology</a> engine
            written in C++17, compiled to a binary <a href="http://webassembly.org">WebAssembly</a>
            <a href="https://github.com/Symatem/symatem.github.io/blob/master/public/js/Symatem.wasm">file</a>
            using <a href="http://clang.llvm.org/docs/ReleaseNotes.html">Clang 4.0</a> and loaded into the browser.
            There some <a href="http://es6-features.org">ES6</a> code,
            which handles <a href="https://github.com/Symatem/symatem-ide/blob/master/lib/OntologyEditor.js">the user interaction</a>
            and <a href="https://github.com/arlac77/WiredPanels">the rendering</a>, is connected to it via these two files:
            <a href="https://github.com/Symatem/CppCodeBase/blob/master/Targets/WASM.cpp">C++ side</a>,
            <a href="https://github.com/Symatem/SymatemWasm/blob/master/SymatemWasm.js">JS side</a>.
            The upper view contains a text representation of the ontology and
            the view below aggregates all triples sharing the same entity in boxes.
            In each box the common entity is displayed on top with a set of attribute (left) and value (right) pairs below.
            The blobs of these symbols are inlined graphically, so they don't have to be explored explicitly.
        </p>
        <select id="codeExamples">
            <option value="Network.sym">Network</option>
        </select>
        <pre><code class="language-symatemHRL" id="code"></code></pre>
        <div id="OntologyEditor">
            <script type="text/javascript" src="../public/js/OntologyEditor.js"></script>
        </div>
        <br />
        <br />
        <h3>Usage</h3>
        <ul>
            <li>Explore:<ul>
                <li>Drag and drop a symbol (box) around to reposition it</li>
                <li>Click on a green or blue socket (circle) to toggle the visibility of the connected symbol</li>
                <li>Click on a red socket to see all symbols indirectly connected to it</li>
                <li>Select a different example from the selection above the code</li>
            </ul><br /></li>
            <li>Edit:<ul>
                <li>Click on a symbol to edit it</li>
                <li>Shift-click on symbols, sockets or wires to select them</li>
                <li>Press backspace to delete the selected objects</li>
                <li>Double-click on the background of the visualizer to find existing symbols or to add new ones</li>
                <li>Drag a wire from a red socket to its symbol and then draw wires from the new green and blue sockets to other symbols to add a new triple</li>
                <li>Click on the source code above to edit it, blur again to apply the changes</li>
            </ul><br /></li>
            <li>Persistate:<ul>
                <li><input id="saveImage" value="Download" type="button" /> the memory image of the ontology as a binary file</li>
                <li>Drop such a binary file in the visualizer to load it (but the state of exploration is lost)</li>
            </ul></li>
        </ul>
        <br />
        <h3>Why use an ontology?</h3>
        <p>
            You probably already stumbled across one of these problems:
        </p>
        <p>
            1. Hierarchical file systems: Lets say you want to sort all your media on your computer.
            You might start with a distinction between images, movies, music, mail etc.
            And then inside the music directory you have to decide whether first group artists or album and have the other one inside,
            like a multi level index. But you have to decide on one of them as top level:
            Either you can have all albums of an artist or all artists of one album together in one place, not both at once.
            Obviously the solution is simple:
            Just delegate the problem to someone else, like your operating systems search bar or a media managment software / database.
            But in both cases we lose all controll over the data and its nearly impossible to interact with it programatically because of the lack of APIs.
            What if we could have such feautures simply build in our operating system and give up the strict hierarchical order and use an ontology instead?
            Then sorting would simply be like a database query or view, which doesn't manipulate or depend on the underling structure.
        </p>
        <p>
            2. You can't simply drag and drop or copy data from one application into another.
            Only in very few cases, when both were explicitly developed to do so, it is possible.
            This is caused by the fact, that all means to process data is trapped inside the applications.
            But it is exactly this domain knowledge, which gives data meaning and therefore value.
            What if all applications could easily share this meta data needed to process data?
            Again an ontology could help out.
        </p>
        <p>
            3. Back references in imperative and functional programming languages:
            Have to be placed manually and before they are needed (searching afterwards is to expensive)
            Can get out of sync
        </p>
        <p>
            4. Relational database schemes: You always need a database scheme and changing it with lots of data inside can be a huge pain.
        </p>
        <br />
        <h3>If an ontology is such a great thing, how come it isn't used everywhere?</h3>
        <p>
            The biggest project in this direction is the so called <a href="https://en.wikipedia.org/wiki/Semantic_Web">semantic web</a>.
            But it has some annoying issues like being composed of too many technologies:
            <a href="https://en.wikipedia.org/wiki/Web_Ontology_Language">OWL</a>,
            <a href="https://en.wikipedia.org/wiki/SPARQL">SPARQL</a>,
            <a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a>,
            <a href="https://en.wikipedia.org/wiki/RDF_Schema">RDFS</a>,
            <a href="https://en.wikipedia.org/wiki/Turtle_(syntax)">Turtle</a>,
            <a href="https://en.wikipedia.org/wiki/Notation3">Notation3</a> etc.
            and a quite <a href="http://milicicvuk.com/blog/2011/07/19/ultimate-problem-of-rdf-and-semantic-web/">broken design</a>.
            Symatem does some things differently to address these problems.
            As you can see above our triples are completely semmetrical,
            so every symbol can be used in each position of a triple.
            Also litterals are not part of the triples but of the symbols instead.
            We call them blobs and they work much more like bytestreams in filesystems with the symbol being the inode.

            But it is still far from being finished or perfect.
            What we are aiming for is for <a href="https://github.com/Symatem/Symatem">Symatem</a>
            to become a unique way of combining all of these in one software architecture:
        </p>
        <ul>
            <li>Programming Language</li>
            <li>Integrated Development Environment</li>
            <li>Ontology Engine / Database / File System</li>
            <li>Operating System / Runtime Environment</li>
        </ul>
        <p>
            For this purpose we research a wide range of ideas including:
            Projectional editing, dataflow programming, concurrency and distribution,
        </p>
        <p>
            Feel free to <a href="mailto:AlexanderMeissner@gmx.net">contact me</a> if you have questions.
            Feedback and contributions are welcome.
        </p>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
    </body>
</html>
