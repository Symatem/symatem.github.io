// Generated by CoffeeScript 1.10.0

var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
SymatemVisualizer = (function() {
    SymatemVisualizer.prototype.canvasArea = [680, 400];

    SymatemVisualizer.prototype.lineHeight = 20;

    SymatemVisualizer.prototype.textOffsetY = 14;

    SymatemVisualizer.prototype.boxWidth = 150;

    SymatemVisualizer.prototype.symbolNames = {
      13: 'Procedure',
      14: 'Execute',
      15: 'Next',
      16: 'Static',
      17: 'Dynamic',
      18: 'Input',
      19: 'Output',
      23: 'Count',
      32: 'Create',
      35: 'Pop',
      36: 'Branch',
      54: 'CloneBlob',
      62: 'LessThan',
      64: 'Comparandum',
      72: 'Add',
      74: 'Subtract',
      75: 'Minuend',
      76: 'Subtrahend',
      1485: 'FiboRec',
      1590: '#a',
      1601: '#b',
      1816: 2,
      2775: 1
    };

    SymatemVisualizer.prototype.triples = [[1485, 14, 1537], [1537, 13, 32], [1612, 19, 1590], [1612, 19, 1601], [1537, 16, 1612], [1537, 15, 1691], [1691, 13, 62], [1743, 19, 1590], [1743, 18, 18], [1691, 17, 1743], [1831, 64, 1816], [1691, 16, 1831], [1691, 15, 1902], [1902, 13, 36], [1952, 18, 1590], [1902, 17, 1952], [2024, 13, 54], [2069, 18, 18], [2069, 19, 19], [2024, 17, 2069], [2024, 15, 2148], [2148, 13, 35], [2211, 23, 1816], [2148, 16, 2211], [2256, 36, 2024], [1902, 16, 2256], [1902, 15, 2327], [2327, 13, 74], [2377, 19, 1590], [2377, 75, 18], [2327, 17, 2377], [2462, 76, 1816], [2327, 16, 2462], [2327, 15, 2531], [2531, 13, 1485], [2581, 19, 1590], [2581, 18, 1590], [2531, 17, 2581], [2531, 15, 2660], [2660, 13, 74], [2708, 19, 1601], [2708, 75, 18], [2660, 17, 2708], [2790, 76, 2775], [2660, 16, 2790], [2660, 15, 2859], [2859, 13, 1485], [2907, 19, 1601], [2907, 18, 1601], [2859, 17, 2907], [2859, 15, 2990], [2990, 13, 72], [3040, 19, 19], [3040, 18, 1590], [3040, 18, 1601], [2990, 17, 3040]];

    SymatemVisualizer.prototype.focusSymbol = function(symbol) {
      var element, i, index, j, ref, ref1;
      this.focusedSymbol = symbol;
      index = this.historyStack.indexOf(symbol);
      if (index > -1) {
        for (i = j = ref = index + 1, ref1 = this.historyStack.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
          this.history.removeChild(this.history.childNodes[index + 1]);
        }
        this.historyStack.splice(index + 1);
      } else {
        element = document.createElement('span');
        element.addEventListener('click', this.focusSymbol.bind(this, symbol));
        this.history.appendChild(element);
        this.historyStack.push(symbol);
      }
      return this.render(false);
    };

    SymatemVisualizer.prototype.render = function(dumpAll) {
      var attribute, box, element, entity, i, j, k, l, len, len1, len2, len3, m, newBoxes, otherBox, ref, ref1, ref2, ref3, ref4, segment, symbol, symbolsToShow, trash, triple, value;
      trash = this.connections.slice();
      newBoxes = {};
      symbolsToShow = [this.focusedSymbol];
      this.addSymbolsToShow = function(symbol) {
        if (this.showAnonymousOnly.checked && this.symbolNames[symbol]) {
          return;
        }
        if (indexOf.call(symbolsToShow, symbol) < 0) {
          return symbolsToShow.push(symbol);
        }
      };
      ref = this.triples;
      for (j = 0, len = ref.length; j < len; j++) {
        triple = ref[j];
        if (triple[0] === this.focusedSymbol) {
          this.addSymbolsToShow(triple[1]);
          this.addSymbolsToShow(triple[2]);
        }
        if (triple[1] === this.focusedSymbol) {
          this.addSymbolsToShow(triple[2]);
          this.addSymbolsToShow(triple[0]);
        }
        if (triple[2] === this.focusedSymbol) {
          this.addSymbolsToShow(triple[0]);
          this.addSymbolsToShow(triple[1]);
        }
      }
      for (k = 0, len1 = symbolsToShow.length; k < len1; k++) {
        symbol = symbolsToShow[k];
        if (dumpAll || !this.boxes[symbol]) {
          newBoxes[symbol] = {
            segments: []
          };
        }
      }
      ref1 = this.triples;
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        triple = ref1[l];
        entity = newBoxes[triple[0]];
        if (entity) {
          entity.segments.push({
            leftType: 1,
            rightType: 2,
            leftSymbol: triple[1],
            rightSymbol: triple[2]
          });
        }
        if (!this.showEAVOnly.checked) {
          attribute = newBoxes[triple[1]];
          if (attribute) {
            attribute.segments.push({
              leftType: 2,
              rightType: 0,
              leftSymbol: triple[2],
              rightSymbol: triple[0]
            });
          }
          value = newBoxes[triple[2]];
          if (value) {
            value.segments.push({
              leftType: 0,
              rightType: 1,
              leftSymbol: triple[0],
              rightSymbol: triple[1]
            });
          }
        }
      }
      ref2 = this.boxes;
      for (symbol in ref2) {
        box = ref2[symbol];
        symbol = parseInt(symbol);
        if (!dumpAll && indexOf.call(symbolsToShow, symbol) >= 0) {
          box.setPosition(symbol === this.focusedSymbol, symbolsToShow);
        } else {
          trash.push(box.group);
          delete this.boxes[symbol];
        }
      }
      for (symbol in newBoxes) {
        box = newBoxes[symbol];
        symbol = parseInt(symbol);
        this.createBox(symbol, box);
        box.setPosition(symbol === this.focusedSymbol, symbolsToShow);
      }
      this.updateNames();
      ref3 = this.boxes;
      for (symbol in ref3) {
        box = ref3[symbol];
        symbol = parseInt(symbol);
        ref4 = box.segments;
        for (i in ref4) {
          segment = ref4[i];
          otherBox = this.boxes[segment.leftSymbol];
          if (otherBox) {
            this.renderConnection(segment.leftCircle, otherBox.circle, segment.leftType);
          }
          otherBox = this.boxes[segment.rightSymbol];
          if (otherBox) {
            this.renderConnection(segment.rightCircle, otherBox.circle, segment.rightType);
          }
        }
      }
      for (m = 0, len3 = trash.length; m < len3; m++) {
        element = trash[m];
        element.classList.remove('fadeIn');
        element.classList.add('fadeOut');
      }
      return window.setTimeout(function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = trash.length; n < len4; n++) {
          element = trash[n];
          results.push(element.remove());
        }
        return results;
      }, 250);
    };

    SymatemVisualizer.prototype.renderConnection = function(from, to, type) {
      var connection, diffX, maxY;
      from = from.getAbsolutePosition();
      to = to.getAbsolutePosition();
      connection = document.createElementNS(this.svg.namespaceURI, 'path');
      if (this.showHangingLines.checked) {
        diffX = to[0] - from[0];
        maxY = Math.max(to[1], from[1]) + 20;
        connection.setAttribute('d', 'M' + from[0] + ',' + from[1] + 'C' + (from[0] + diffX * 0.25) + ',' + maxY + ' ' + (from[0] + diffX * 0.75) + ',' + maxY + ' ' + to[0] + ',' + to[1]);
      } else {
        if (Math.abs(from[0] - to[0]) < Math.abs(from[1] - to[1])) {
          connection.setAttribute('d', 'M' + from[0] + ',' + from[1] + 'C' + to[0] + ',' + from[1] + ' ' + from[0] + ',' + to[1] + ' ' + to[0] + ',' + to[1]);
        } else {
          connection.setAttribute('d', 'M' + from[0] + ',' + from[1] + 'C' + from[0] + ',' + to[1] + ' ' + to[0] + ',' + from[1] + ' ' + to[0] + ',' + to[1]);
        }
      }
      connection.setAttribute('class', 'connection fadeIn colorType' + type);
      this.svg.appendChild(connection);
      return this.connections.push(connection);
    };

    SymatemVisualizer.prototype.elementUpdateName = function(element, symbol) {
      if (this.showSymbolIDs.checked) {
        element.classList.remove('disabled');
        element.textContent = '#' + symbol;
        return;
      }
      if (this.symbolNames[symbol]) {
        element.classList.remove('disabled');
        return element.textContent = this.symbolNames[symbol];
      } else {
        element.classList.add('disabled');
        return element.textContent = '#' + symbol;
      }
    };

    SymatemVisualizer.prototype.updateNames = function() {
      var box, index, ref, ref1, results, segment, symbol;
      ref = this.historyStack;
      for (index in ref) {
        symbol = ref[index];
        this.elementUpdateName(this.history.childNodes[index], symbol);
      }
      ref1 = this.boxes;
      results = [];
      for (symbol in ref1) {
        box = ref1[symbol];
        this.elementUpdateName(box.nameElement, symbol);
        results.push((function() {
          var j, len, ref2, results1;
          ref2 = box.segments;
          results1 = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            segment = ref2[j];
            this.elementUpdateName(segment.leftElement, segment.leftSymbol);
            results1.push(this.elementUpdateName(segment.rightElement, segment.rightSymbol));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    SymatemVisualizer.prototype.createBox = function(symbol, box) {
      var circleRadius, focusCenter, focusEllipse, getAbsolutePosition, i, left, line, posY, rect, ref, results, right, segment;
      focusCenter = [this.canvasArea[0] / 2, this.canvasArea[1] * 0.15];
      focusEllipse = [this.canvasArea[0] * 0.35, this.canvasArea[1] * 0.6];
      box.width = this.boxWidth;
      box.height = (box.segments.length + 1) * this.lineHeight;
      box.setPosition = function(isFocused, symbolsToShow) {
        var angle, angleTable, index, maxIndex, prevPos;
        prevPos = [box.x, box.y];
        if (isFocused) {
          box.x = focusCenter[0] - box.width / 2;
          box.y = focusCenter[1];
        } else {
          maxIndex = symbolsToShow.length - 2;
          index = symbolsToShow.indexOf(symbol) - 1;
          angleTable = [[Math.PI / 2], [Math.PI / 3, Math.PI / 3 * 2], [Math.PI / 4, Math.PI / 4 * 2, Math.PI / 4 * 3]];
          if (maxIndex < angleTable.length) {
            angle = angleTable[maxIndex][index];
          } else {
            angle = index / maxIndex * Math.PI;
          }
          box.x = Math.cos(angle) * focusEllipse[0] + focusCenter[0] - box.width / 2;
          box.y = Math.sin(angle) * focusEllipse[1] + focusCenter[1];
        }
        if (prevPos[0]) {
          box.animation.setAttribute('from', prevPos[0] + ',' + prevPos[1]);
        } else {
          box.animation.setAttribute('from', box.x + ',' + box.y);
        }
        box.animation.setAttribute('to', box.x + ',' + box.y);
        return box.animation.beginElement();
      };
      this.boxes[symbol] = box;
      getAbsolutePosition = function() {
        return [box.x + parseInt(this.getAttribute('cx')), box.y + parseInt(this.getAttribute('cy'))];
      };
      box.group = document.createElementNS(this.svg.namespaceURI, 'g');
      box.group.setAttribute('class', 'fadeIn');
      this.svg.appendChild(box.group);
      box.animation = document.createElementNS(this.svg.namespaceURI, 'animateTransform');
      box.animation.setAttribute('attributeName', 'transform');
      box.animation.setAttribute('fill', 'freeze');
      box.animation.setAttribute('type', 'translate');
      box.animation.setAttribute('dur', '0.25s');
      box.group.appendChild(box.animation);
      rect = document.createElementNS(this.svg.namespaceURI, 'rect');
      rect.setAttribute('rx', 10);
      rect.setAttribute('ry', 10);
      rect.setAttribute('width', box.width);
      rect.setAttribute('height', box.height);
      box.group.appendChild(rect);
      circleRadius = this.lineHeight / 5;
      box.circle = document.createElementNS(this.svg.namespaceURI, 'circle');
      box.circle.setAttribute('cx', box.width / 2);
      box.circle.setAttribute('cy', -circleRadius * 2);
      box.circle.setAttribute('r', circleRadius);
      box.circle.getAbsolutePosition = getAbsolutePosition.bind(box.circle);
      box.group.appendChild(box.circle);
      box.nameElement = document.createElementNS(this.svg.namespaceURI, 'text');
      box.nameElement.setAttribute('text-anchor', 'middle');
      box.nameElement.setAttribute('x', box.width / 2);
      box.nameElement.setAttribute('y', this.textOffsetY);
      box.nameElement.addEventListener('click', this.focusSymbol.bind(this, symbol));
      box.group.appendChild(box.nameElement);
      ref = box.segments;
      results = [];
      for (i in ref) {
        segment = ref[i];
        posY = this.lineHeight + this.lineHeight * i;
        line = document.createElementNS(this.svg.namespaceURI, 'path');
        line.setAttribute('d', 'M0 ' + posY + 'H' + box.width);
        box.group.appendChild(line);
        left = document.createElementNS(this.svg.namespaceURI, 'text');
        left.setAttribute('text-anchor', 'start');
        left.setAttribute('x', circleRadius * 4.5);
        left.setAttribute('y', posY + this.textOffsetY);
        left.addEventListener('click', this.focusSymbol.bind(this, segment.leftSymbol));
        box.group.appendChild(left);
        segment.leftElement = left;
        right = document.createElementNS(this.svg.namespaceURI, 'text');
        right.setAttribute('text-anchor', 'end');
        right.setAttribute('x', box.width - circleRadius * 4.5);
        right.setAttribute('y', posY + this.textOffsetY);
        right.addEventListener('click', this.focusSymbol.bind(this, segment.rightSymbol));
        box.group.appendChild(right);
        segment.rightElement = right;
        segment.leftCircle = document.createElementNS(this.svg.namespaceURI, 'circle');
        segment.leftCircle.setAttribute('cx', Math.round(circleRadius * 2.5));
        segment.leftCircle.setAttribute('cy', posY + this.lineHeight * 0.5);
        segment.leftCircle.setAttribute('r', circleRadius);
        segment.leftCircle.setAttribute('class', 'colorType' + segment.leftType);
        segment.leftCircle.getAbsolutePosition = getAbsolutePosition.bind(segment.leftCircle);
        box.group.appendChild(segment.leftCircle);
        segment.rightCircle = document.createElementNS(this.svg.namespaceURI, 'circle');
        segment.rightCircle.setAttribute('cx', Math.round(box.width - circleRadius * 2.5));
        segment.rightCircle.setAttribute('cy', posY + this.lineHeight * 0.5);
        segment.rightCircle.setAttribute('r', circleRadius);
        segment.rightCircle.setAttribute('class', 'colorType' + segment.rightType);
        segment.rightCircle.getAbsolutePosition = getAbsolutePosition.bind(segment.rightCircle);
        results.push(box.group.appendChild(segment.rightCircle));
      }
      return results;
    };

    function SymatemVisualizer(element, serializedState) {
      var arrowMarker, arrowPath, svgDefs;
      this.historyStack = [];
      this.boxes = [];
      this.connections = [];
      this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      this.svg.setAttribute('width', this.canvasArea[0]);
      this.svg.setAttribute('height', this.canvasArea[1]);
      element.appendChild(this.svg);
      svgDefs = document.createElementNS(this.svg.namespaceURI, 'defs');
      this.svg.appendChild(svgDefs);
      arrowMarker = document.createElementNS(this.svg.namespaceURI, 'marker');
      arrowMarker.setAttribute('id', 'arrow');
      arrowMarker.setAttribute('markerWidth', 7);
      arrowMarker.setAttribute('markerHeight', 6);
      arrowMarker.setAttribute('refX', 6);
      arrowMarker.setAttribute('refY', 3);
      arrowMarker.setAttribute('orient', 'auto');
      svgDefs.appendChild(arrowMarker);
      arrowPath = document.createElementNS(this.svg.namespaceURI, 'path');
      arrowPath.setAttribute('d', 'M0,1L5,3L0,5z');
      arrowMarker.appendChild(arrowPath);
      this.history = document.createElement('div');
      this.history.setAttribute('class', 'history');
      element.appendChild(this.history);
      this.options = document.createElement('div');
      this.options.setAttribute('class', 'options');
      element.appendChild(this.options);
      this.showEAVOnly = document.createElement('input');
      this.showEAVOnly.setAttribute('type', 'checkbox');
      this.showEAVOnly.setAttribute('checked', 'on');
      this.showEAVOnly.addEventListener('click', this.render.bind(this, true));
      this.options.appendChild(this.showEAVOnly);
      this.options.appendChild(document.createTextNode(' EAV only'));
      this.options.appendChild(document.createElement('br'));
      this.showAnonymousOnly = document.createElement('input');
      this.showAnonymousOnly.setAttribute('type', 'checkbox');
      this.showAnonymousOnly.setAttribute('checked', 'on');
      this.showAnonymousOnly.addEventListener('click', this.render.bind(this, false));
      this.options.appendChild(this.showAnonymousOnly);
      this.options.appendChild(document.createTextNode(' Anon only'));
      this.options.appendChild(document.createElement('br'));
      this.showHangingLines = document.createElement('input');
      this.showHangingLines.setAttribute('type', 'checkbox');
      this.showHangingLines.addEventListener('click', this.render.bind(this, false));
      this.options.appendChild(this.showHangingLines);
      this.options.appendChild(document.createTextNode(' Hanging'));
      this.options.appendChild(document.createElement('br'));
      this.showSymbolIDs = document.createElement('input');
      this.showSymbolIDs.setAttribute('type', 'checkbox');
      this.showSymbolIDs.addEventListener('click', this.updateNames.bind(this));
      this.options.appendChild(this.showSymbolIDs);
      this.options.appendChild(document.createTextNode(' Symbol IDs'));
      this.focusSymbol(1485);
    }

    return SymatemVisualizer;

})();
